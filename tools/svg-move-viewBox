#! /usr/bin/env phantomjs
// -*- js2 -*-

var webpage = require('webpage')
  , URL;
  ;

if (phantom.args.length < 1 || phantom.args.length > 1) {
  console.log('Usage: svg-move-viewBox source.svg');
  phantom.exit();
}
else {
  URL = phantom.args[0];
  load(URL, onload);
}

function load(url, fn) {
  var page = webpage.create();
  page.onConsoleMessage = function(msg) {
    console.log(msg);
  };
  page.open(url, function (status) {
    if (status !== 'success')
      console.log('Unable to load ' + url);
    else
      fn(page);
  });
}

function onload(page) {
  page.onConsoleMessage = function(msg) {
    console.log(msg);
    phantom.exit();
  };
  page.evaluate(onSVG);
}

function onSVG() {
  function array(ish, start) { return _sl.call(ish, start || 0); }
  var _sl = [].slice
    , svg = document.documentElement
    ;
  moveViewBox();
  console.log((new XMLSerializer).serializeToString(svg));

  // Move the top/left coordinate of the viewBox to x, y (0, 0 by default), and
  // updates all shape elements accordingly, to retain their original position.
  // Retains full precision from the coordinates the original file amounted to.
  // NOTE: Does not handle transforms right, or accommodate non-shape elements!
  function moveViewBox(x, y) {
    var svg     = document.documentElement
      , viewBox = svg.getAttribute('viewBox')
      , coords  = viewBox.match(/[+-]?(?:\.\d+|\d+(?:\.\d+)?)/g)
      , dx      = sub(x = x || '0', coords[0])
      , dy      = sub(y = y || '0', coords[1])
      , prec_x  = Math.max(prec(x), prec(coords[0]))
      , prec_y  = Math.max(prec(y), prec(coords[1]))
      , move    =
        { path:     path
        , rect:     xy
        , line:     xnyn
        , circle:   cxcy
        , ellipse:  cxcy
        , polygon:  pnts
        , polyline: pnts
        }
      , elem
      ;

    for (elem in move)
      array(document.querySelectorAll(elem)).forEach(move[elem]);

    coords = coords.slice(0, 2).map(dxdy).concat(coords.slice(2));
    svg.setAttribute('viewBox', coords.join(' '));

    // edits coord i&1 = 0 by dx steps, coord i&1 = 1 by dy steps
    function dxdy(n, i) {
      return n & 1 ? add(n, dy, prec_y) : add(n, dx, prec_x);
    }

    // add n and m (strings), retaining the maximum precision of n and m
    // (if m is a Number, p is its number of precision decimals)
    function add(n, m, p) { return op(function(a,b) { return a+b; }, n, m, p); }
    function sub(n, m, p) { return op(function(a,b) { return a-b; }, n, m, p); }
    function op(op, n, m, p) {
      if (typeof n !== 'string')
        throw new Error('n='+ n +' not a string! Needed to retain precision.');
      if (typeof m === 'string') {
        p = prec(m);
        m = parseFloat(m);
      }
      p = Math.max(p, prec(n));
      n = parseFloat(n);
      n = op(n, m).toFixed(p).replace(/\.0*$/, ''); // zap excess decimals
      var z = /(.*[1-9])(0{3,})$/.exec(n);
      if (z) n = z[1] +'e'+ z[2].length;
      return n.replace(/^0\./, '.') // >0 but <1 needs no leading zero
              .replace(/(\.\d*[1-9])0*$/, '$1'); // no trailing zeroes
    }

    // returns the number of decimals of n (string only)
    function prec(n) {
      var t = typeof n;
      if (t !== 'string')
        throw new Error('Only strings retain their precision; got '+ t +'!');
      n = /\.(\d*)/.exec(n);
      if (!n) return 0;
      return n[1].length;
    }

    function edit(me, prop) {

    }

    // lexes an SVG path d attribute into an array of all its raw cmd|num string
    // components - stripping all whitespace as it goes along, while not parsing
    // the actual numbers(, which would lose their precision!)
    // `max`, if given, only does the first `max` steps
    function lexd(d, max) {
      var re = lex.re, segs = [], m, c, n;
      re.lastIndex = 0;
      max = max || Infinity;
      while ((m = re.exec(d, re.lastIndex)) &&
             ((c = m[1]).length + (n = m[2]).length) &&
             max--) {
        if ((c = c.replace(/[^a-z]/gi, '')))
          segs.push(c); // adds just the cmd
        if (n)
          segs.push(n); // adds just the num - if there was one; z won't have it
      }
      return segs;
    }
    lexd.re = /([a-z\s,]*)([-+]?(?:\d+|)(?:\.\d+)?(?:e[-+]?\d+(?:\.\d+))?)/gi;

    // get the `n`th number in path (sub)string `s`, as a string
    function numn(s, n) {
      var x; n = n || 0;
      while (n-- >= 0) {
        if ((x = numn.re.exec(s))) {
          s = x[2];
          x = x[1];
        }
      }
      return x;
    }
    numn.re = /^[,\sa-z]*([-+]?(?:\d+|)(?:\.\d+)?(?:e[-+]?\d+(?:\.\d+))?)(.*)/i;

    function path(p) {
      var d = p.getAttribute('d')
        , D = lexd(d, 2) // M, X, Y
        , x = sub(D[1], dx)
        , y = sub(D[2], dy)
        ;
      convertToRelative(p);
      p.pathSegList.removeItem(0);
      p.setAttribute('d', 'm'+ x +' '+ y + p.getAttribute('d'));
    }
    function xy(e) {
      var x = parseFloat(e.getAttribute('x') || '0')
        , y = parseFloat(e.getAttribute('y') || '0');
      e.setAttribute('x', x + dx);
      e.setAttribute('y', y + dy);
    }
    function xnyn(l) {
      var x1 = parseFloat(e.getAttribute('x1') || '0')
        , x2 = parseFloat(c.getAttribute('x2') || '0')
        , y1 = parseFloat(e.getAttribute('y1') || '0')
        , y2 = parseFloat(c.getAttribute('y2') || '0');
      l.setAttribute('x1', x1 + dx);
      l.setAttribute('x2', x2 + dx);
      l.setAttribute('y1', y1 + dy);
      l.setAttribute('y2', y2 + dy);
    }
    function cxcy(c) {
      var cx = parseFloat(c.getAttribute('cx') || '0')
        , cy = parseFloat(c.getAttribute('cy') || '0');
      c.setAttribute('cx', cx + dx);
      c.setAttribute('cy', cy + dy);
    }
    function pnts(p) {
      for (var P = p.points, l = P.numberOfItems, i = 0, c; i < l; i++) {
        c = P.getItem(i);
        c.x += dx;
        c.y += dy;
      }
    }
  }

  // based on http://stackoverflow.com/a/9677915/1130377
  function convertToRelative(path) {
    function set(type) {
      var args = array(arguments, 1)
        , rcmd = 'createSVGPathSeg'+ type +'Rel'
        , rseg = path[rcmd].apply(path, args);
      segs.replaceItem(rseg, i);
    }
    var dx, dy, x0, y0, x1, y1, x2, y2, segs = path.pathSegList;
    for (var x = 0, y = 0, i = 0, len = segs.numberOfItems; i < len; i++) {
      var seg = segs.getItem(i)
        , c   = seg.pathSegTypeAsLetter;
      if (/[MLHVCSQTAZz]/.test(c)) {
        if ('x1' in seg) x1 = seg.x1 - x;
        if ('x2' in seg) x2 = seg.x2 - x;
        if ('y1' in seg) y1 = seg.y1 - y;
        if ('y2' in seg) y2 = seg.y2 - y;
        if ('x'  in seg) dx = -x + (x = seg.x);
        if ('y'  in seg) dy = -y + (y = seg.y);
        switch (c) {
          case 'M': set('Moveto',dx,dy);                   break;
          case 'L': set('Lineto',dx,dy);                   break;
          case 'H': set('LinetoHorizontal',dx);            break;
          case 'V': set('LinetoVertical',dy);              break;
          case 'C': set('CurvetoCubic',dx,dy,x1,y1,x2,y2); break;
          case 'S': set('CurvetoCubicSmooth',dx,dy,x2,y2); break;
          case 'Q': set('CurvetoQuadratic',dx,dy,x1,y1);   break;
          case 'T': set('CurvetoQuadraticSmooth',dx,dy);   break;
          case 'A': set('Arc',dx,dy,seg.r1,seg.r2,seg.angle,
                        seg.largeArcFlag,seg.sweepFlag);   break;
          case 'Z': case 'z': x = x0; y = y0; break;
        }
      }
      else {
        if ('x' in seg) x += seg.x;
        if ('y' in seg) y += seg.y;
      }
      // store the start of a subpath
      if (c == 'M' || c == 'm') {
        x0 = x;
        y0 = y;
      }
    }
    path.setAttribute('d', path.getAttribute('d').replace(/Z/g, 'z'));
  }
}
